/*
 * JBoss, Home of Professional Open Source.
 * Copyright 2025 Red Hat, Inc., and individual contributors
 * as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.jboss.pnc.sentinel.test;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Base64;
import java.util.Collection;
import java.util.Set;

import org.eclipse.microprofile.config.inject.ConfigProperty;
import org.jboss.pnc.dto.Artifact;
import org.jboss.pnc.dto.Build;
import org.jboss.pnc.dto.BuildConfigurationRevision;
import org.jboss.pnc.sentinel.PncService;
import org.jboss.pnc.sentinel.provenance.config.ProvenanceConfigProvider;
import org.jboss.pnc.sentinel.provenance.model.Provenance;
import org.jboss.pnc.sentinel.provenance.utils.CosignWrapper;
import org.jboss.pnc.sentinel.provenance.utils.CosignWrapper.SignedBlobResult;
import org.jboss.pnc.sentinel.provenance.utils.ProvenanceUtils;
import org.jboss.pnc.sentinel.test.ProvenanceGenerateCommandTest.CustomPncServiceProfile;
import org.jboss.pnc.sentinel.test.utils.AlternativePncService;
import org.jboss.pnc.sentinel.utils.ObjectMapperProvider;
import org.jboss.pnc.sentinel.utils.SchemaValidator;
import org.jboss.pnc.sentinel.utils.SchemaValidator.ValidationResult;
import org.jboss.pnc.sentinel.utils.TestResources;
import org.junit.jupiter.api.Test;

import com.fasterxml.jackson.databind.JsonNode;

import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.junit.QuarkusTestProfile;
import io.quarkus.test.junit.TestProfile;
import jakarta.inject.Inject;

@QuarkusTest
@TestProfile(CustomPncServiceProfile.class)
class ProvenanceGenerateCommandTest {

    private static final String PNC_BUILD_ID = "BJ3TGDXPQWYAC";
    private static final String PNC_BUILDCONFIG_ID = "17586";
    private static final Integer PNC_BUILDCONFIG_REV = 2742483;

    public static class CustomPncServiceProfile implements QuarkusTestProfile {
        @Override
        public Set<Class<?>> getEnabledAlternatives() {
            return Set.of(AlternativePncService.class);
        }
    }

    @Inject
    private PncService pncService;

    @Inject
    private ProvenanceConfigProvider provenanceConfig;

    @ConfigProperty(name = "cosign.password")
    String cosignPassword;

    @Test
    void testCreateProvenance() throws IOException {

        // Mock PNC service
        Build pncBuild = pncService.getBuild(PNC_BUILD_ID);
        BuildConfigurationRevision pncBuildConfigRevision = pncService
                .getBuildConfigRevision(PNC_BUILDCONFIG_ID, PNC_BUILDCONFIG_REV);
        Collection<Artifact> builtArtifacts = pncService.getBuiltArtifacts(PNC_BUILD_ID);
        Collection<Artifact> resolvedArtifacts = pncService.getDependencies(PNC_BUILD_ID);

        Provenance provenance = ProvenanceUtils.createFullPNCBuildProvenance(
                pncBuild,
                pncBuildConfigRevision,
                builtArtifacts,
                resolvedArtifacts,
                provenanceConfig);

        String generatedProvenance = ObjectMapperProvider.json().writeValueAsString(provenance);
        System.out.println("\n✅ Generated a provenance for PNC build '" + PNC_BUILD_ID + "' -->");
        System.out.println(generatedProvenance);
        System.out.println("<--");

        String expectedProvenance = TestResources.asString("pnc/provenance/provenance.json");
        assertEquals(
                expectedProvenance.trim(),
                generatedProvenance.trim(),
                "The generated provenance is different from the expected one");

        ValidationResult result = SchemaValidator.validate("v1", generatedProvenance);
        assertTrue(result.isValid(), "Validation of provenance againt the schema did not pass");
        assertTrue(result.getErrors().isEmpty(), "The errors from the schema validation is not empty");
    }

    @Test
    void testSignAndVerifyBlobBytes() throws IOException, InterruptedException {
        // Pre-generated provenance content
        String provenance = TestResources.asString("pnc/provenance/provenance.json");

        // Get the private and public keys (previsouly generated by Cosign)
        Path cosignPrivateKeyPath = Paths.get("src", "test", "resources", "cosign", "cosign-v1.key");
        Path cosignPublicKeyPath = Paths.get("src", "test", "resources", "cosign", "cosign-v1.pub");

        // Write the provenance to a temp file
        Path provenanceFile = Files.createTempFile("prov-", ".json");
        Files.writeString(provenanceFile, provenance);

        // Let's save the file as build-<BUILD_ID>.intoto.jsonl
        // The important part is that the whole built artifacts are included in the subject
        CosignWrapper cosign = new CosignWrapper(cosignPrivateKeyPath, cosignPublicKeyPath, cosignPassword);

        // Use the Cosign wrapper to sign the provenance content using the above keys and password
        SignedBlobResult signedBlobResult = cosign.signBlob(provenanceFile);

        assertNotNull(signedBlobResult.signature());
        assertTrue(signedBlobResult.signature().length > 0);
        System.out.println(
                "\n✅ Generated a raw provenance signature of '" + signedBlobResult.signature().length + "' bytes.");
        System.out.println(
                "\n✅ Generated a JSONL in-toto Statement of '" + signedBlobResult.bundleJson().length() + "' bytes.");

        // Now use the Cosign wrapper to verify the signature
        boolean ok1 = cosign.verifyBlob(provenance.getBytes(), signedBlobResult.signature(), null);
        assertTrue(ok1, "Signature should verify with cosign");
        System.out.println("✅ Verified the signature against the provenance payload and the public key.");

        boolean ok2 = cosign.verifyBlob(provenance.getBytes(), null, signedBlobResult.bundleJson().getBytes());
        assertTrue(ok2, "Bundle should verify with cosign");
        System.out.println("✅ Verified the bundle against the provenance payload and the public key.");

        // Write the content to files
        Files.write(Path.of("provenance.sig"), signedBlobResult.signature());
        Files.writeString(Path.of("provenance.intoto.jsonl"), signedBlobResult.bundleJson());

        // Verify with signature
        ok1 = cosign.verifyBlob(provenanceFile, Path.of("provenance.sig"), null);
        assertTrue(ok1, "Signature should verify with cosign");

        // Verify with bundle
        ok2 = cosign.verifyBlob(provenanceFile, null, Path.of("provenance.intoto.jsonl"));
        assertTrue(ok2, "Bundle should verify with cosign");

        JsonNode root = ObjectMapperProvider.json().readTree(signedBlobResult.bundleJson());

        System.out.println("✅ Produced Bundle (intoto.jsonl):");
        System.out.println(ObjectMapperProvider.json().writerWithDefaultPrettyPrinter().writeValueAsString(root));

        // 🔐 1. Top-level signature
        String base64Signature = root.path("base64Signature").asText();
        System.out.println("--> Signature: " + base64Signature);

        // 📜 2. Rekor bundle metadata
        JsonNode rekorBundle = root.path("rekorBundle");
        String signedEntryTimestamp = rekorBundle.path("SignedEntryTimestamp").asText();
        System.out.println("--> Rekor SignedEntryTimestamp: " + signedEntryTimestamp);

        // 🪵 3. Payload fields
        JsonNode payload = rekorBundle.path("Payload");
        String integratedTime = payload.path("integratedTime").asText();
        String logIndex = payload.path("logIndex").asText();
        String logID = payload.path("logID").asText();

        System.out.println("--> Rekor Integrated Time: " + integratedTime);
        System.out.println("--> Rekor Log Index: " + logIndex);
        System.out.println("--> Rekor Log ID: " + logID);

        // 📦 4. Decode the body (base64)
        String bodyBase64 = payload.path("body").asText();
        String decodedBody = new String(Base64.getDecoder().decode(bodyBase64));

        // 📄 5. Parse the decoded body again (optional)
        JsonNode body = ObjectMapperProvider.json().readTree(decodedBody);
        System.out.println(
                "--> Rekor Decoded Body: "
                        + ObjectMapperProvider.json().writerWithDefaultPrettyPrinter().writeValueAsString(body));

        Files.deleteIfExists(Path.of("provenance.sig"));
        Files.deleteIfExists(Path.of("provenance.intoto.jsonl"));
    }
}
